namespace NF.Network.Transfer.Protobuf
{
	using System;
	using System.IO;
	using System.Net;
	using System.Threading;
	using Google.Protobuf;
	using NF.Network.Protocol.Interface;
	using NF.Network.Task;

	public abstract class BaseSender : Sender<Google.Protobuf.IMessage>
	{
		CookieContainer _cookie_container = new CookieContainer();
		public int TimeoutMilliseconds { get; set; }

		public class ActorReply<R>
		{
			public int RequestId { get; set; }
			public string ResultType { get; set; }
			public R ResultData { get; set; }
			public Exception Exception { get; set; }
		}

		public BaseSender(int timeout_milliseconds = 10000)
		{
			Init (timeout_milliseconds);
		}

		protected virtual void Init(int timeout_milliseconds)
		{
			System.Net.ServicePointManager.ServerCertificateValidationCallback = ((sender, certificate, chain, sslPolicyErrors) => true);
			System.Net.ServicePointManager.Expect100Continue = false;
			this.TimeoutMilliseconds = timeout_milliseconds;
		}


            public virtual Task<R> Send<R>(Google.Protobuf.IMessage msg) where R : new()
		{
			string url = "http://127.0.0.1:8080";
			var uri = new Uri (url);

			HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(uri);
			httpWebRequest.Method = "POST";
			httpWebRequest.CookieContainer = this._cookie_container;
			httpWebRequest.KeepAlive = true;
			httpWebRequest.Timeout = this.TimeoutMilliseconds;

			byte[] b = msg.ToByteArray ();
			using (var stream = httpWebRequest.GetRequestStream())
			{
				stream.Write(b, 0, b.Length);
			}

			var task = new SlimTask<R> ();
			task.WebRequest = httpWebRequest;
			task.WaitEvent = new ManualResetEvent(false);
			//httpWebRequest.BeginGetRequestStream(new AsyncCallback(
			httpWebRequest.BeginGetResponse(new AsyncCallback(FinishRequest<R>), task);
			return task;
		}


            protected virtual void FinishRequest<R>(IAsyncResult result) where R : new()
		{
			// Get result from stream

			var task = (result.AsyncState as SlimTask<R>);
			var response = task.WebRequest.EndGetResponse(result);
			var reply = GetReplyFromStream<R>(response.GetResponseStream());

			// Make a task completed

			if (reply.Exception == null)
			{
				task.Result = reply.ResultData;
			}
			else
			{
				task.Exception = reply.Exception;
			}
		}

            protected virtual ActorReply<R> GetReplyFromStream<R>(Stream stream) where R : new()
		{
			var d = new R();
			var msg = (Google.Protobuf.IMessage)d;
			msg.MergeFrom (stream);

			// var msg = (Google.Protobuf.IMessage)new AutoGenerated.Protocol.RHello () { R1 = 11, R2 = 33333 };

			var ret = new ActorReply<R> ();
			ret.ResultData = (R)msg;
			return ret;
		}
	}
}

namespace NF.Network.Task
{
	// ref: https://github.com/SaladLab/Akka.Interfaced/blob/master/samples/SlimHttp/Program.Client/SlimTask.cs
	using System;
	using System.Net;
	using System.Threading;
	using NF.Network.Protocol.Interface;

	internal class SlimTask : Task
	{
		private Exception _exception;

		internal HttpWebRequest WebRequest { get; set; }
		internal ManualResetEvent WaitEvent { get; set; }

		public object WaitHandle
		{
			get { return WaitEvent; }
		}

		public TaskStatus Status
		{
			get; internal set;
		}

		public Exception Exception
		{
			get { return _exception; }
			internal set
			{
				if (IsCompleted)
					throw new InvalidOperationException("Already completed. status=" + Status);

				_exception = value;
				Status = TaskStatus.Faulted;
				WaitEvent.Set();
			}
		}

		public bool IsCompleted
		{
			get
			{
				return Status == TaskStatus.RanToCompletion ||
					Status == TaskStatus.Canceled ||
					Status == TaskStatus.Faulted;
			}
		}
	}

	internal class SlimTask<TResult> : SlimTask, Task<TResult>
	{
		private TResult _result;

		public TResult Result
		{
			get
			{
				if (IsCompleted == false)
					WaitEvent.WaitOne();

				if (Status == TaskStatus.RanToCompletion)
					return _result;
				else if (Exception != null)
					throw Exception;
				else
					throw new InvalidOperationException();
			}
			internal set
			{
				if (IsCompleted)
					throw new InvalidOperationException("Already completed. status=" + Status);

				_result = value;
				Status = TaskStatus.RanToCompletion;
				WaitEvent.Set();
			}
		}
	}

	internal static class SlimTaskExtension
	{
		public static void Wait(this Task task)
		{
			((SlimTask)task).WaitEvent.WaitOne();
		}
	}
}
